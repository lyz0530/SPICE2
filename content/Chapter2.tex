\chapter{电路仿真总览}
\label{chap:2}

尽管电路仿真程序在大小和能力上相当不同，但是大多数电路仿真程序的架构是相似的。图\ref{图2.1}原理上展示了该架构。如这幅图所示，一个仿真程序包含五个主要的子程序：输入，建立，分析，输出，和工具。子程序间通过存储在该程序的一片公共区域的数据结构来交互。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter2/图2.1.png}
    \caption{SPICE电路元件}
    \label{图2.1}
\end{figure}

输入子程序读取输入文件，从输入构建数据结构，并检查数据结构中存在的明显的用户错误。数据结构，经过输入阶段，包含了电路完整的，自洽的描述。

输入子程序被成功执行后，建立子程序将构建分析子程序要求的额外的数据结构。一些仿真程序不包含建立子程序。SPICE中的建立子程序构建指针系统，该系统被分析子程序的稀疏矩阵子函数使用。其他程序，比如ASTAP\cite{ref-28,ref-29}，产生和编译FORTRAN程序，该FORTARN程序把分析作为建立步骤的一部分来执行。

分析子程序是仿真程序中的主要部分。该子程序执行输入文件中指定的电路分析。这些分析的输出被存在中央内存或者硬盘里，以便输出子程序后面处理。

最后，输出子程序产生用户指定的输出。大多数仿真程序有着对输出数据产生线打印机绘制和列表列出的能力。有些程序，比如ISPICE\cite{ref-30}，有着图形终端绘制的能力和在仿真输出上进行广泛的后处理能力。

很多仿真程序，包括ASTAP，ISPICE，ECAP2\cite{ref-31,ref-32}，NET2\cite{ref-33}，和CIRCUS2\cite{ref-34}，包含着一个工具子程序，该子程序创造和更新电路和元件模型的圆盘库。该能力容许用户存储和检索电路，而且容许几个设计人员共享器件模型信息。SPICE没有包含工具子程序，因为圆盘库对SPICE在University of California，Berkeley的使用模式不是必要的。

在一个电路仿真程序的开发中，所有子程序都应该被小心关注。因为程序的用户与输入和输出子程序交互，程序这两个部分使用的灵活性和简便性，在很大程度上，决定了整个仿真程序使用的灵活性和简便性。

尽管输入和输出子程序决定了仿真程序使用起来的难易程度，但是分析子程序在决定程序效率上发挥着决定性作用。而且，分析子程序中使用的算法比仿真程序的其他子程序中的算法更加复杂。出于这些原因，在一个仿真程序上耗费的开发精力中最大的部分要算给可靠和有效的电路分析技术的开发。

\section{电路分析}
电路仿真程序的分析部分决定了电路数学表达式的数值解。为了完成从物理电路到数学系统方程的转化，电路中的每一个元件会被用一个数学模型表示。在SPICE中实现的元件模型在本论文的附录\ref{App:2}进行了描述。几年的实践经验表明这些模型对大多数仿真问题是适用的。然而，其他元件模型也可以被使用。

电路中的每一个元件被建模后，描述完整电路的方程系统由每一个元件的模型方程和拓扑约束决定，拓扑约束是由元件间的互连关系决定的。拓扑约束反映了Kirchoff电流定律（KCL）和Kirchoff电压定律（KVL）。电路方程，在总体上，是有着如下形式的代数差分方程系统，

\begin{equation}
    F(x,\dot{x},t)=0
    \label{eq:2.1}
\end{equation}

这里x是未知的电路变量向量，$\dot{x}$是x的时间导数，而F，大体上，表示一个非线性算子。

对在电子电路设计中感兴趣的不同特殊情况，电路分析决定了(\ref{eq:2.1})的解。一个DC分析，比如，通常被会唤起决定(\ref{eq:2.1})的静态解。在这种情况下，向量$\dot{x}$是0，而(\ref{eq:2.1})会被简化成一个非线性方程系统。

本章的剩余部分介绍对执行DC分析，AC分析，和瞬态分析必不可少的数值分析方法。这些数值方法是：方程构建，线性方程求解，非线性方程求解，和数值积分。电路仿真程序的分析部分的实现为了执行这四种基本的数值步骤，要求开发有效的和可靠的算法。

\section{线性DC分析}
电路仿真程序中最基本的分析是对线性电路的DC求解。通常，DC解是为静态情况决定的，也就是说，向量$\dot{x}$为0的情况。电路中的能量存储之后会被忽略，通过把电容视为开路，电感视为短路\footnote{如果指定的初始条件与静态解无关，能量存储元件随后会被当作电压源或者电流源。例如，如果初始电容电压和电感电流被指定，电容随后会被当作电压源，而电感会被当做电流源。在SPICE中，电容电流和电感电压是初始条件。因此，在DC分析中，电容被当作电流源，电感被当作电压源。}。因为所有时间的导数都为0，且电路是线性的，所以DC分析的电路方程是线性的代数方程系统。线性电路的DC分析因此只要求一种构造电路方程的方法以及一种该方程的线性求解算法。

有很多不同的构造电路方程的方法。节点分析\cite{ref-7}可能是最简单的计算方法。在节点分析中，非基准（非地）节点电压是未知的电路变量。这种对变量的选择自动确保了电路解满足KVL。电路方程随后可以通过在每一个非基准节点上根据KVL写出一个方程来决定。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter2/图2.2.png}
    \caption{示例电路}
    \label{图2.2}
\end{figure}

如果图\ref{图2.2}中的电容被忽略，节点分析法将产生如下的方程系统:

\begin{equation}
\begin{bmatrix}
\frac{1}{R_1}+\frac{1}{R_2} &-\frac{1}{R_2}  \\
-\frac{1}{R_2} &\frac{1}{R_2}+\frac{1}{R_3}  \\
\end{bmatrix}\begin{bmatrix}
v_1 \\
v_2
\end{bmatrix}=\begin{bmatrix}
I_0 \\
0\end{bmatrix}
\label{eq:2.2}
\end{equation}

通常，节点分析产生节点方程系统，

\begin{equation}
    Yv = j
    \label{eq:2.3}
\end{equation}

这里Y是节点导纳矩阵，v是节点电压向量，而j是电流激励向量。

节点分析的主要优点是它的计算简便性。对于只包含电阻和独立电流源的DC分析，Y和j是通过如下规则构造的：$y_{ii}$是连接到节点i上的所有电导的和，$y_{ij}$是连接节点i和节点j之间的所有电导的和的负，$j_i$是所有流入节点$i$的独立电流源的和。很清楚，为这种线性DC分析特殊情况构造的(\ref{eq:2.3})可以在10或者20行FORTRAN代码内实现。

线性DC分析的剩余任务是(\ref{eq:2.3})的解。高斯消去或者LU分解\cite{ref-35}之类的等价方法能够最大效率地完成这个任务。对大多数电路应用来说，(\ref{eq:2.3})中的矩阵Y包含很少的非零元项；也就是说，Y是非常稀疏的。如果这种固有的稀疏性能够被识别，那么求解(\ref{eq:2.3})需要的计算精力会得到相当程度的减少。出于这个原因，稀疏矩阵方法在CANCER的最早版本中就进行了实现，并且在CANCER和SPICE的所有版本中都被保留了。事实上，在最近被开发出来的大多数仿真程序中，稀疏矩阵方法都在被使用。

\section{线性AC分析}
小信号AC分析比线性DC分析稍微复杂一些。因为在电路中的所有元件都是，按照定义，线性的，所以非线性电路元件会被用等效的线性化模型建模。线性化模型的参数值，反过来，由DC工作点分析决定。SPICE中的四种非线性元件的线性化模型在本论文的附录\ref{App:2}中进行了讨论。

AC分析决定了电路在正弦稳态情况下的小信号解。所有输入源都是相同输入频率的正弦波，尽管电源会被分配不同的相对相位值。因为电路处于正弦稳态，所以在把差分电路方程转换到频域上时启用了相位法\cite{ref-7}。电阻，电容，和电感的导纳如下给出，

\begin{equation}
    Y_R = \frac{1}{R}
    \label{eq:2.4}
\end{equation}

\begin{equation}
    Y_C\footnote{在原文中，该变量为$Y_R$} = j\omega C
    \label{eq:2.5}
\end{equation}

\begin{equation}
    Y_I = \frac{1}{j\omega L}
    \label{eq:2.6}
\end{equation}

这里$\omega$是输入频率的值，以弧度为单位。

线性AC分析的方程用与线性DC分析的相同方法就可构造，除了，当然，AC分析的电路方程是复数。例如，图\ref{图2.2}中电路的节点方程是

\begin{equation}
\begin{bmatrix}
\frac{1}{R_2}+\frac{1}{R_3} +j\omega C_1 &-\frac{1}{R_3}-j\omega C_1  \\
-\frac{1}{R_3}-j\omega C_1 &\frac{1}{R_3}+j\omega (C_1+C_2)  \\
\end{bmatrix}\begin{bmatrix}
v_1 \\
v_2
\end{bmatrix}=\begin{bmatrix}
I_0e^{-j\phi} \\
0\end{bmatrix}
\label{eq:2.7}
\end{equation}

这里$\phi$是输入源的相对相位。

通常，分配给特定源的值对DC分析来说会比AC分析不同。电源供电，例如，通常有着0 AC值，而这里输入源经常有0 DC值。如果电路只有一个AC输入，那么把输入设置为单位1幅度和0相位是方便的。在AC分析中的每一个电路变量的值就会等于该变量关于输入的转移函数的值。

在一个仿真程序中AC分析能力的实现与线性DC分析的实现相似。AC分析中的电路方程，当然，是复数的。然而，用在DC分析中的相同的构造和线性求解算法会被用在AC分析中。而且，实现AC小信号分析不要求新方法。

\section{非线性DC分析}
如果电路包含的元件由非线性方程建模完成，那么DC解可以通过线性化的解的迭代序列得到。Newton-Raphson算法\cite{ref-37,ref-38}是线性化最常用的方法。这个方法用泰勒级数近似电路中的每一个非线性，泰勒级数在一阶项之后会被截断。

例如，考虑图\ref{图2.3}中给出的二极管特性。二极管电流用熟悉的二极管方程\footnote{参数$V_t$是热电压，等于kT/q，这里k是Boltzman常数，q是电子电荷，而T是用Kelvin度为单位的绝对温度。在室温下，$V_t$近似是26 mV。}建模，

\begin{equation}
    I_D=I_S[exp(\frac{V_D}{V_t})-1]
    \label{eq:2.8}
\end{equation}

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter2/图2.3.png}
    \caption{理想二极管特性。}
    \label{图2.3}
\end{figure}

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter2/图2.4.png}
    \caption{(a)二极管极性定义；(b)线性化的等效电路}
    \label{图2.4}
\end{figure}

这里$I_D$和$V_D$的极性如图\ref{图2.4}a所示。在任一工作点$V_0$，二极管特性会被$V_0$处的切线近似，如图\ref{图2.3}所示。该近似等价于通过一个等价的线性电导，$g_{eq}$，和一个等价的独立电流源，$I_{eq}$的并联来建模该二极管。$g_{eq}$的值是方程\ref{eq:2.8}关于$V_D$的导数：

\begin{equation}
    g_{eq}=\frac{I_S}{V_t}exp(\frac{V_D}{V_t})
    \label{eq:2.9}
\end{equation}

$I_{eq}$的值由下式给出：
\begin{equation}
    I_{eq}=I_D-g_{eq}V_D
    \label{eq:2.10}
\end{equation}

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter2/图2.5.png}
    \caption{(a)示例电路；(b)线性化的等效电路}
    \label{图2.5}
\end{figure}

图\ref{图2.5}a中电路展示了线性化的过程。对DC解来说，两个电容被忽略了。二极管用它的线性化等效来建模，得到的电路如图\ref{图2.5}b所示。该电路的线性化节点方程为

\begin{equation}
\begin{bmatrix}
\frac{1}{R_1}+\frac{1}{R_2} &-\frac{1}{R_2}  \\
-\frac{1}{R_2} &\frac{1}{R_2}+g_{eq}  \\
\end{bmatrix}\begin{bmatrix}
v_1 \\
v_2
\end{bmatrix}=\begin{bmatrix}
I_0 \\
-I_{eq}\end{bmatrix}
\label{eq:2.11}
\end{equation}
这里$g_{eq}$和$I_{eq}$由(\ref{eq:2.9})和(\ref{eq:2.10})决定。

迭代解序列从对解的初始“猜测”开始。所有非线性模型方程随后会关于这个假定的工作点进行线性化。关于这个线性等效电路的电路方程的构建和求解与线性DC分析中用的步骤相同\footnote{假定线性化模型方程和随后构造电路方程系统的过程与非线性电路方程和随后线性化整套电路方程产生同样的结果。\cite{ref-37}中证明如果舍入误差可以忽略，这个假设就成立。}。电路的解随后被用作下一次“猜测”，重复该过程。当连续的迭代解在一些误差范围内一致时，迭代停止。

非线性DC分析比线性DC分析更复杂。第一，必须将对非线性模型方程的评估和它们的导数加入到程序中。第二，线性化的电路方程必须被组合和多次求解以获得解。在实践中，大多数电路的DC工作点在5-30次Newton迭代中可以被决定。

求解过程的迭代本质也容许非收敛解的可能。对于一个特定的电路，如果算法收敛失败，那么整个仿真程序对该电路的设计起不到任何作用。因此，在电路仿真程序中，一个可靠的和有效的非线性求解方法是相当重要的。

\section{瞬态分析}
瞬态分析决定了电路在一个特定的时间范围（0,T）内的时域响应。初始时间点被随意定义为时间0。该初始解要不被用户指定，要不，更方便地，被DC工作点分析决定。

瞬态解是通过把时间间隔（0,T）分成离散的时间点（0,t1,t2,...T）来计算得到的。在每一个时间点，数值积分算法会被用来把每一个能量存储元件的差分模型方程转换为等效的代数方程。这个转换之后，时间点的解可以用与求解非线性DC工作点相同的方式迭代决定。

数值积分算法要不是显式的，要不是隐式的；然而，隐式方法对电路仿真来说更优先。Backward Euler算法是最简单的隐式方法。该方法通过下面的关系被定义

\begin{equation}
    X_{n+1} = x_n + h_n\dot{x_{n+1}}
    \label{eq:2.12}
\end{equation}

这里$x_{n+1}=x(t_{n+1})$，$x_n=x(t_n)$，而时间步长，$h_n$，通过下面的方程定义

\begin{equation}
    h_n = t_{n+1}-t_n
    \label{eq:2.13}
\end{equation}

考虑，作为一个例子，用下面的方程建模的一个电容

\begin{equation}
    Q_c=f(V_c)
    \label{eq:2.14}
\end{equation}

\begin{equation}
    I_c = \dot{Q_c}
    \label{eq:2.15}
\end{equation}
这里$I_c$和$V_c$的极性如图\ref{图2.6}所示。如果把(\ref{eq:2.12})代入(\ref{eq:2.15})，可以得到下面的代数方程：

\begin{equation}
    I_{n+1}=\frac{f(V_{n+1})}{h_n}-\frac{Q_n}{h_n}
    \label{eq:2.16}
\end{equation}
如果(\ref{eq:2.14})是非线性方程，那么(\ref{eq:2.16})明显会成为一个非线性方程。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter2/图2.6.png}
    \caption{一个电容性支路的极性定义。}
    \label{图2.6}
\end{figure}

图\ref{图2.7}a中所示电路提供了积分过程的一个示例。电容C1是一个线性电容，而C2是一个非线性扩散电容，由下面的电荷方程定义，
\begin{equation}
    Q_2 = \tau I_s[exp(\frac{V_{C2}}{V_t})-1]
    \label{eq:2.17}
\end{equation}
电路中的二极管像之前一样由(\ref{eq:2.8})定义。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter2/图2.7.png}
    \caption{(a)瞬态分析的示例电路；(b)等效“准-DC”电路}
    \label{图2.7}
\end{figure}

当(\ref{eq:2.12})为了C1和C2被代入模型方程的时候，图\ref{图2.7}b中展示的“准-DC”电路就有了结果。元件Q1和Q2的模型方程通过下面的方程给出，
\begin{equation}
    I_{Q1}(t_{n+1})=\frac{C_1}{h_n}[V_{Q1}(t_{n+1})-V_{Q1}(t_n)]
    \label{eq:2.18}
\end{equation}

\begin{equation}
    I_{Q2}(t_{n+1})=\frac{\tau I_S}{h_n}[exp(\frac{V_{Q2}(t_{n+1})}{V_t})-1]-\frac{Q_2(t_n)}{h_n}
    \label{eq:2.19}
\end{equation}
在每一个时间点决定图\ref{图2.7}a中电路的解因此等价于决定图\ref{图2.7}b中的电路的DC解。

(\ref{eq:2.12})的误差近似是积分方法的局部截断误差（LTE）。这个误差，反过来是，正比于时间步长$h_n$。如果(\ref{eq:2.12})，和以及的(\ref{eq:2.16})，都是精确的近似，那么之后时间步长必须足够小到使得局部截断误差可以被忽略。

仿真程序加入瞬态分析能力因此需要两个程序加入。第一个，能量存储差分模型方程到等价的“准-DC”代数方程的转换必须被实现。第二个，必须提供评估积分算法的局部截断误差和调整时间步长以使得解误差保持在合理水平。

\section{总结}
一个电路仿真程序包含几个重要的子程序，而这些子程序中的每一个在仿真程序的整个设计过程中都需要被小心关照。分析部分是仿真程序的中心部分。对于一个仿真，该子程序消耗整个计算精力的最大部分。而且，分析子程序比做程序的剩余部分需要更多的有经验的数值技术。仿真程序的开发，因此，取决于用一种至关重要的方式开发有效的分析子程序。

分析子程序，反过来，要求四种基本的计算算法：构造方程，线性方程解，非线性解，和数值积分。这四种方法的角色如图\ref{图2.8}中的流程图所示。该图描述了固定时间步长下的瞬态分析。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter2/图2.8.png}
    \caption{瞬态分析程序的流程图。}
    \label{图2.8}
\end{figure}

在每一个时间点，时间是递增的，而模型方程中的时间导数部分是用数值积分方法近似的。随后一系列的Newton迭代会被用来决定该时间点的解。每一次Newton迭代，反过来，要求在构造和求解线性化的电路方程后对模型方程进行线性化。收敛获得后，时间点解会被存储，而下一个时间点会被尝试。所有的时间点被求解完成后，仿真结果会被打印，而程序也将停止。

对于DC分析，图\ref{图2.8}中的外部时间循环没有被使用；一旦获得了解，程序会打印出DC工作点并停止。而且，如果电路只含有线性元件，那么内部Newton迭代循环会被取消，因为在一次循环中总是可以得到解。

SPICE中不同类型的电路分析需要的相对计算精力如表\ref{表2.1}所示。该表给出了决定一个差分对电路的DC工作点，DC转移特性，小信号频率响应，和瞬态响应需要的点数，迭代次数，和cpu执行时间。这些分析的仿真输出在本论文的第\ref{chap:1}章给出。该电路包含14个节点，4个晶体管，5个电阻，和3个电压源。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter2/表2.1.png}
    \caption{不同分析方法间迭代次数和CPU时间的比较}
    \label{表2.1}
\end{figure}

DC工作点求解计算要求8次Newton迭代和0.181 cpu 秒的执行时间。该cpu时间中的大部分消耗在了工作点的打印上。101个点的DC转移曲线求解需要233次Newton迭代和2.20 cpu秒的执行时间。在DC转移曲线求解时间中没有包含输出时间。因此，在DC分析中的计算精力大约是每次Newton迭代9.4ms。101个频率点的AC分析需要1.495 cpu秒，或者每次迭代近似14.8ms。瞬态分析，对于49个时间点，需要141次迭代和1.990 cpu秒，或者每次Newton迭代近似14.1 ms。
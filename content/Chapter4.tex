\chapter{线性方程组的解}
\label{chap:4}
所有的电路分析步骤都要求对如下形式的线性方程系统求解
\begin{equation}
    Ax = b
    \label{eq:4.1}
\end{equation}
这里A是系数矩阵，x是电路变量的未知向量，而b是激励向量。在电路仿真问题中产生的系数矩阵典型地有50或者100阶的方程；然而，几千个方程系统求解的仿真问题的预测也并不困难。

系数矩阵的大规模被如下事实抵消，对于电路仿真应用，A中的大多数系数都是0，也就是说，电路方程系统是非常稀疏的。即使对于一个中等规模的电路，为了实现有效求解，电路方程的内在稀疏性也必须被识别出来。

本章从直接消去法求解(\ref{eq:4.1})的介绍开始。之后会描述求解稀疏矩阵的LU分解的实现。对于保持系数矩阵的稀疏性必要的重排序算法会被介绍和比较。这些计算方法的实现方法随后被提出。最后，通过迭代法决定线性方程系统解的方法将被介绍。

\section{直接消去}
方程(\ref{eq:4.1})通过在(\ref{eq:4.1})的两边同时乘以$A^{-1}$就可以被求解完成
\begin{equation}
    x = A^{-1}b
    \label{eq:4.2}
\end{equation}
如果$A^{-1}$不存在，那么就不存在解，求解(\ref{eq:4.1})的任何方法都会失效。因为矩阵求逆要求的计算代价是其他直接消去方法的三倍\cite{ref-49}，所以在仿真程序中很少用到直接求逆。

有两种不要求A的逆的直接消去的等效方法：高斯消去和LU分解。在一个激励向量的情况下，两种方法要求同样多的计算代价；然而，如果要求的是几个激励向量的解，那么LU分解要求更少的计算代价\cite{ref-35}。

在LU分解下，原矩阵被因式化，或者分解，成一个下三角矩阵L和一个上三角矩阵U的乘积。原方程随后可以被重新写成
\begin{equation}
    Ax = LUx = b
    \label{eq:4.3}
\end{equation}

为了得到唯一的分解，L或者U的对角项被设置为1。分解执行完成后，通过前向替代和后向回代就可以得到解。前向迭代要求L矩阵：
\begin{equation}
    y = Ux = L^{-1}b
    \label{eq:4.4}
\end{equation}
后向回代要求U矩阵：
\begin{equation}
    x = U^{-1}y = U^{-1}L^{-1}b
    \label{eq:4.5}
\end{equation}
因为L和U的三角特性，所以为了执行(\ref{eq:4.4})或者(\ref{eq:4.5})，不论$L^{-1}$还是$U^{-1}$都需要被确定。

\section{LU分解}
LU分解有几种等效的方法。这里提的方法来自Doolittle\cite{ref-49}。L的对角元被设置为1。如果有N个方程，该方法需要N-1步。第一步的流程是
\begin{equation}
    a_{1j} = a_{1j} \quad j = 1,2,\dots,N
    \label{eq:4.6}
\end{equation}
\begin{equation}
    l_{j1} = a_{j1}/a_{11} \quad j = 2,3,\dots,N
    \label{eq:4.7}
\end{equation}
对于第$i$步（$i=2,3,\dots,N-1$），计算过程更复杂：
\begin{equation}
    u_{ij} = a_{ij}-\sum^{i-1}_{k=1}l_{ik}u_{ki} \quad j = i,i+1,\dots,N
    \label{eq:4.8}
\end{equation}
\begin{equation}
    l_{ji} = (a_{ji}-\sum^{i-1}_{k=1}l_{jk}u_{ki})/u_{ii} \quad j = i+1,i+2\footnote{原文中是i+1},\dots,N
    \label{eq:4.9}
\end{equation}

L和U的结构使得两列数组可以延用A原来的存储数组。LU分解算法被修正以使得，在第i步，A的第i个上三角行被U的第i个上三角行取代，而A的第i个下三角列被L的第i个下三角列取代。这些是通过在第i步（$l=1,2,\dots,N-1$）用下面的算法取代方程(\ref{eq:4.6}-\ref{eq:4.9})完成的：
\begin{equation}
    a_{ji} = a_{ji}/a_{ii} \quad j = i+1,i+2,\dots,N
    \label{eq:4.10}
\end{equation}
\begin{equation}
    a_{jk} = a_{jk}-a_{ji}a_{ik} \quad \begin{matrix}
j = i+1,i+2,\dots,N \\
k = i+1,i+2,\dots,N
\end{matrix}
\label{eq:4.11}
\end{equation}

\section{前向和后向替代}
一旦矩阵被分解为L和U，通过一次前向替代和一次后向回代就可以得到解。算法被安排得以使所有中间计算都被存在了激励向量中。前向替代要求N-1步；在第i步（$i=1,2,\dots,N-1$），流程是
\begin{equation}
    b_j = b_j - l_{ji}b_i \quad j = i+1,i+2,\dots,N
    \label{eq:4.12}
\end{equation}

后向回代也要求N-1步；在第i步（$i=N,N-1,\dots,2$），流程是
\begin{equation}
    b_i = b_i/a_{ii}
    \label{eq:4.13}
\end{equation}
\begin{equation}
    b_j = b_j -a_{ji}b_i \quad j =1,2,\dots,i-1
    \label{eq:4.14}
\end{equation}
最后，后向回代那步通过如下得到
\begin{equation}
    b_1 = b_1/u_{11}
    \label{eq:4.15}
\end{equation}

有时候，通过行而不是列来处理上三角矩阵U会更有效。修正算法，对于第一步，是
\begin{equation}
    b_N = b_N/u_{NN}
    \label{eq:4.16}
\end{equation}
在第i步（$i = N-1,N-2,\dots,1$）
\begin{equation}
    b_i = (b_i - \sum^N_{j=i+1}u_{ij})/u_{ii}
    \label{eq:4.17}
\end{equation}

\section{操作计数}
给定方程系统的直接求解算法，可以对求解要求的计算代价进行评估。所有的矩阵操作都是下面两种类型：
\begin{equation}
    A = A-B*C
    \label{eq:4.18}
\end{equation}

\begin{equation}
    A = A/B
    \label{eq:4.19}
\end{equation}
为了简化统计，这两种操作被认为需要同样数量的中央处理器执行时间。尽管(\ref{eq:4.19})在一些计算机上要求的cpu时间比(\ref{eq:4.13})明显更多，但是(\ref{eq:4.18})和(\ref{eq:4.19})在CDC 6400上要求差不多相同数量的cpu执行时间。

如果$r_i$是第i行中上三角行系数的数量，而$c_i$是第i列中下三角列系数的数量，那么在分解过程中第i行和列的操作的数量是$c_i + c_i r_i$；在第i行的前向替代的操作数是$c_i$，而对后向回代，第i行要求$r_i+1$次操作。因此，获得解需要的总的操作数是
\begin{equation}
    0 = \sum^N_{i=1}[(c_i+c_i r_i)+c_i+(r_i+1)]
    \label{eq:4.20}
\end{equation}
对于非稀疏技术，
\begin{equation}
    c_i = r_i = i-1
    \label{eq:4.21}
\end{equation}
所以(\ref{eq:4.20})减到
\begin{equation}
    0 = [\frac{n^3-n}{3}]+[\frac{n^2-n}{2}]+[\frac{n^2+n}{2}]
    \label{eq:4.22}
\end{equation}
因此，分解要求$n^3$阶的操作，而前向和后向迭代都要求$n^2$阶的操作。

\section{舍入误差}
计算机上实现的大多数仿真程序要不有相对大的字长（$\ge 48$位），要不有拓展的精度。出于这个原因，在线性方程组求解中发生的舍入误差通常只占整体解误差的一小部分。然而，对于遇到的有着明显病态条件的方程例子，能最小化舍入误差的特殊算法就是必要的了\cite{ref-49,ref-50}。

在LU分解的每一步，如果对角元的绝对值大于任意非对角行或者列的元素，那么舍入误差就会最小。这个条件可以通过部分选主元得到部分满足，部分选主元在分解的每一步要不交换行要不交换列，或者可以在分解的每一步同时交换行和列得到完全满足。

寻找最优主元和记录哪行哪列已经被交换的额外记录会使得原来基本简单的流程复杂化。进一步，选主元的概念会与稀疏矩阵求解不兼容，因为无论何时调整主元顺序，整个稀疏矩阵指针系统必须被重建。相反，直接消去法的稀疏矩阵实现依赖方程条件良好这一事实。

即使方程集合的条件良好，悲观地预测，舍入误差也会用因子$1+2log_{10}N$，这里N是方程的个数\cite{ref-49}，来减少有效位数。因此，100个方程的解会比机器字长的精度少五个有效位，而1000个方程的解会比机器字长的精度少七个有效位。因为电路仿真正常要求三到六位的有效精度，所以机器字长必须要兼容10到13位的有效位数。对大多数计算机，双精度运算对保证精度是必要的。因为CDC 6400有60位字长，等效为14个有效位数，所以单精度运算就够了。

\section{稀疏矩阵技术}
为了有效求解稀疏矩阵，整数指针集合对系数矩阵中的每个非零元分配一个独特的位置是必要的。如果对角元是非零元，它们就不需要指针参考。而且，如果激励向量元也是非零元，那么激励向量也可以用非稀疏的方式存储。剩余的非对角系数被存储在一个单下标的阵列中。在SPICE程序中，存储的顺序是先上三角行，后下三角列。SPICE中使用的矩阵指针方案如图\ref{图4.1}所示。如果有N个方程和整体$N_0$个非对角项，那么这个方案要求两个长度为N+1的整数数组和一个长度为$N_0$的整数数组。数组的含义如下。IUR数组是用来访问行的指针。第i行元素通过AO(IUR(I+1)-1)被存在地址AO(IUR(I))处。如果IUR(I)等于IUR(I+1)，那么在第i行就没有上三角行元素。IO数组被用来构建行或者列的位置。例如，在第三行，有两个上三角行元素(IUR(4)-IUR(3)=2)。它们是$a_{34}$项（IUR(2)=2，IO(2)=4），值为-1.0（AO(2)=-1.0），和$a_{35}$项（IO(3)=5），值为-3.0（AO(3)=-3.0）。ILC数组被用来用一种同样的方式访问列。这个指针方案不是唯一的；只要每个矩阵系数被用一种有效的方式引用，那么一个合适的指针方案的选择就是随意的。
\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter4/图4.1.png}
    \caption{稀疏矩阵指针系统。}
    \label{图4.1}
\end{figure}

在一些例子中，系数矩阵有着对称或者近似对称的结构。节点分析，例如，产生了一个在结构上非常近似对称的电路方程系统。通过引入少量0系数，矩阵结构可以被做的对称。这种对称带来的指针结构只有非对称情况的一半大\cite{ref-36}。特别地，图\ref{图4.1}中的ILC数组不是必要的，而IO数组只需要一半大。减小的指针远远补偿了在稀疏矩阵数组中保留的额外的0系数。

电路描述被读取和错误检查后，所有的电路元件会立即被搜索，以此来确立哪些矩阵项是非零的。接下来，矩阵的行和列会以一种在分解步骤中最小化额外填元的方式来重新排序，而填元项会被加入指针。

\section{填元的控制}
在分解过程中，矩阵元素也许会变成非零的，即使它们原来是0值的。仔细查看分解步骤(\ref{eq:4.11})就能明显发现这点。即使(\ref{eq:4.11})中的$a_{jk}$是0，如果$a_{ji}$和$a_{ik}$都是非零的，那么$a_{jk}$会变成非零的。

这种填元的发生降低了原系数矩阵的稀疏性，减弱了使用稀疏矩阵技术带来的优势。而且，一个填元项或许会产生额外的填元项；这就是说，填充会传播。

分解中可行的单自由度是系数矩阵的行和列分解的顺序。如果舍入误差可以被忽略，那么不同的分解顺序虽然能够产生同样的结果，但会要求完全不同的操作数和填元。重排序算法尝试选择一种能够最小化操作数的分解顺序。

最简单的重排序算法来自Markowitz\cite{ref-51}。能够产生的最多的填元数量是上三角行项的数量和下三角列项的数量的乘积。已经分解的列中的行项，和已经分解的行中的列项，被从积中排除了，因为它们不能产生填元。Markowitz算法的进行是通过把有最小的行-列积的行-列对，和因此，能够在最坏情况下产生最少数量的填元项的行-列对作为下一个主元。在一个组合的情况下，有着最少列元素的行-列对会被选择，而在进一步组合的情况下，遇到的第一个行-列对会被选择。在选择下一个主元前，产生的所有填元项必须被加入到指针中。

一种更容易理解的重排序算法由Berry\cite{ref-36}提出，并在CANCER程序中进行了实现\cite{ref-2}。这个算法为每一个可能的行-列对计算了实际会产生的填元的量，而不是假定填元会最大化。产生最少填元数量的行-列对随后会被选择为下一个主元。在组合(tie)的情况下，Berry提出有最多行和列元素的行-列对应该被选择。在进一步组合情况下，遇到的第一个行-列对会被选择。Nahkla等人\cite{ref-52}后来实现的Berry算法提出tie-breaking算法应该是有最少行和列元素的行-列对。

\section{重排序算法的比较}
Markowitz，Berry和Nahkla的重排序算法在SPICE中进行了实现，并且用本论文附录\ref{App:1}中描述的十个基准电路进行了测试。这个测试的结果在表\ref{表4.1}中给出。对这十个电路，Berry算法和Nahkla算法产生最一致的结果。Berry算法中的任意一种和Markowitz算法之间最大的差别是对MECLIII电路，操作数有5\%的不同。平均上，决定重排序时，Berry算法要求的中央处理器的时间是Markowitz算法的两倍。
\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter4/表4.1.png}
    \caption{十个基准电路的重排序算法的对比。}
    \label{表4.1}
\end{figure}
因为测试的电路产生的结果不一致，所以对不同重排序算法进行了统计测试。在第一个测试中，假定矩阵是对称的，非零非对角行和列项的数量的分布如图\ref{图4.2}。维度为50和100的20个矩阵被随机产生，并用这三种算法进行了重排序。这个测试的结果在表\ref{表4.2}中给出。这些结果表明Nahkla的tie-breaking过程能稍微好一点；然而，这些算法中的任意两个之间都没有本质上的区别。
\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter4/图4.2.png}
    \caption{第一个统计测试的行和列非对角元的分布。}
    \label{图4.2}
\end{figure}

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter4/表4.2.png}
    \caption{第一个统计测试的重排序算法的对比。}
    \label{表4.2}
\end{figure}

在第二个统计测试中，矩阵再一次被假定为对称的，而从分布中选择的非零非对角行和列项的数量如图\ref{图4.3}所示。这个分布产生的矩阵更能代表实际的网络矩阵。只有Markowitz算法和Nahkla算法被包含进了这个序列的测试。维度为50，100，200，400，600，800，和1000的20个矩阵被产生，并且用这两种算法进行了重排序。这一套测试的结果在表\ref{表4.3}中给出。再一次，对于所有被测试的例子，算法间的主要差别是决定重排序时的计算代价，而不是重排序本身。因为两种方法产生实际上相同的排序，所以Markowitz方法更受欢迎，这是由于决定重排序时它要求明显更少的计算代价。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter4/图4.3.png}
    \caption{第二个统计测试的行和列非对角元的分布。}
    \label{图4.3}
\end{figure}

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter4/表4.3.png}
    \caption{第二个统计测试的重排序算法的对比。}
    \label{表4.3}
\end{figure}

另一个由Hsieh和Ghausi\cite{ref-53}提出的重排序算法用一种和Berry算法相似的方式进行，但是它产生填元可能性更小的行-列对，在概率的意义上，被选为下一个主元。这个算法产生的重排序虽然没有Berry或者Nahkla算法有效但是比Markowitz算法有效。因为Berry算法和Markowitz算法的差别在本质上是不可区分的，所以Berry算法和Hsieh-Ghausi算法之间的区别也可以忽略不计，而且可以得出结论Hsieh-Ghausi算法在重排序中获得的收益与需要的额外的计算代价相比，并不值得。

\section{程序开发}
线性方程求解算法最简单的实现是一个FORTRAN子程序。在分解中，(\ref{eq:4.11})中的系数$a_{jk}$不能直接被访问。相反，为了找到指向$a_{jk}$项的指针，第j行必须被搜索。这个搜索通过在一个附加的MEMO数组中存储$a_{jk}$的位置可以被去掉，不过会有额外的内存开销。

因为求解函数规模较小、思路直白，所以它们可以用汇编语言取代FORTRAN轻松被编码。使用汇编语言能够较好地利用寄存器，消除很多冗余的负载/存储。再一次，函数要不搜索$a_{jk}$项的位置，要不可以在一个MEMO数组中存储它们的位置。

最后，花费一些内存，一套机器代码指令可以被生成并存放在内存中。执行该套机器代码指令取代执行通用求解函数。因为获得解要求的数学运算属于两种类型(\ref{eq:4.18})和(\ref{eq:4.19})，所以机器代码的产生不是一个有重要意义的任务。网络结果是一个定制的机器程序，不包含环路或者索引，因此应该尽可能地有效。

五种可能的方法\footnote{汇编语言是由University of California, Berkeley的Electronics Research Laboratory的E. Cohen编写的。}在SPICE中进行了实现，并且用本论文的附录\ref{App:1}中描述的十个基准电路进行了测试。DC和瞬态分析的测试结果在表\ref{表4.4}中给出，而AC分析的结果在表\ref{表4.5}中进行了引用。整个内存需求，不包括程序长度，在表\ref{表4.6}中给出。名为“W/O MEMO”的列表示没有附加的存储数组，而名为“W/MEMO”的列表示有附加的存储数组。表\ref{表4.4}-\ref{表4.5}中的最后一列，名为LOAD TIME，列出了构建电路方程要求的平均时间。表\ref{表4.4}-\ref{表4.5}中所有的时间都是以ms计的。
\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter4/表4.4.png}
    \caption{DC或者瞬态分析中求解方法的执行时间。}
    \label{表4.4}
\end{figure}

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter4/表4.5.png}
    \caption{AC分析中求解方法的执行时间。}
    \label{表4.5}
\end{figure}

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter4/表4.6.png}
    \caption{瞬态分析和AC分析中求解方法的内存需求。}
    \label{表4.6}
\end{figure}

从这个数据得到的最有意义的结论是用汇编代码编写的矩阵函数是值得付出的。汇编函数在DC和瞬态分析中快56\%，而在AC分析中快39\%。而且，汇编函数不要求额外的内存。

MEMO数组的使用几乎没有产生什么提高。该数组在DC和瞬态求解中有11\%-12\%的平均提升，不过在中央内存方面增加了9\%的开销。对于AC分析，MEMO数组在8\%额外内存代价的情况下产生了6\%-9\%的平均提高。

机器代码生成可以在执行时间上提供大幅度改善。这些测试表明对于DC和瞬态分析，在FORTRAN代码上有72\%的提高，在汇编代码上有34\%的提高。然而，存储机器代码要求的内存开销会把整体内存要求提高60\%。内存上的这个增加是否可以被接受，当然，取决于计算机系统和使用的账单算法。在AC分析中，代码生成通过FORTRAN代码会节省50\%的执行时间，而通过汇编代码只能节省15\%的时间。对AC分析来说，内存方面将增加125\%。很明显，和汇编代码比较，内存上的增加换来执行时间上最适度的减少并不值当\footnote{这些测试后，一种用复杂函数调用来减少内存需求的方法由E. Cohen提出。然而，执行时间上15\%的减少仍然不能为增加的40\%内存辩护。}。

表\ref{表4.4}-\ref{表4.5}中的数据也建立了方程求解函数的相对重要性。DC或者瞬态分析的每一步Newton迭代由一个矩阵负载组成，该负载之后是方程的求解。对DC或者瞬态分析，如果使用FORTRAN函数，那么方程求解函数随后消耗的执行时间是一次Newton迭代的45\%。如果采用汇编函数，这个百分比会掉到26\%。最后，如果采用机器代码生成，求解函数只占一次Newton迭代时间的19\%。

对AC分析来说，程序的负载和求解部分的重要性相当不同。每个频率点会重新要求一个负载和一次方程求解。如果使用FORTRAN求解函数，求解方程将占用每个频率点求解的74\%的时间。如果实现了汇编函数，求解函数消耗每个频率点求解的63\%的时间。如果使用了机器代码生成，这个百分比会被减到59\%。

\section{迭代技术}
线性方程系统可以被迭代求解，非常像非线性方程求解的方式。Gauss-Seidel方法\cite{ref-49}是使用最广泛的迭代方法。Gauss-Seidel方法的每次完整迭代要求$N^2$次操作。如果迭代次数少于$N/3$，Gauss-Seidel方法要求的计算代价低于直接消去。除此之外，在迭代的最后，Gauss-Seidel方法必要地从一个新的初始猜测开始；因此，在求解中出现的任何舍入误差只会来自最后一次迭代。

如果方程集合是对角占优的，Gauss-Seidel方法就会收敛，尽管收敛率取决于特定的系数矩阵。即使使用节点构造法，系数矩阵也并不总是对角占优的；因此Gauss-Seidel算法的收敛性不能保证。进一步，已经证明，尽管对于迭代方法来说舍入误差比直接法危害更小，但是还有这两种方法发生了同样的舍入误差的例子\cite{ref-49}。然而，对于字长度较小的计算机上的实现来说，Gauss-Seidel方法的一些修正是值得的。

迭代求解方法可以被推广为更一般的最小化问题。标量性能索引定义如下
\begin{equation}
    r = (Ax-b)^T(Ax-b)
    \label{eq:4.23}
\end{equation}
最小化算法被用来决定向量x，以使得r最小。决定线性电路x的Fletcher-Powell算法\cite{ref-54}的使用被报道产生了满意的结果\cite{ref-48}；但是在随后的非线性电路的应用中，最小化方法被舍弃了，因为它没有直接消去有效。另一个最小化算法由Agnew\cite{ref-55}报道，但是随后应用到线性网络仿真\cite{ref-55}表明该方法要求两倍的直接消去的计算代价；另外，在一些例子中，该方法没有收敛到正确的解。

\section{总结}
线性方程系统的求解是整个电路仿真任务中一个重要的先决条件。该解通过LU分解的直接消去法可以简单获得。因为电路方程系统天生是稀疏的，所以稀疏矩阵方法被用来满足合理的中央内存需求和执行时间。

稀疏矩阵方法的实现是一个相对轻松的任务。一个访问稀疏矩阵的整数指针系统在程序执行的建立阶段被确定。一旦这个指针系统建立，与非稀疏方法相比，电路方程系统的构建和求解就要求很少的额外代价。

在分解中发生的填元将减弱原系数矩阵的稀疏性，并降低系数矩阵技术的优势。在代表性电路和随机产生的范围为50个到1000个方程的矩阵上的测试表明任何可行的重排序算法产生的填元总量没有实质差别。重排序方程系统的Markowitz算法是最有吸引力的一种选择，因为决定重排序顺序时该算法要求相当少的计算代价。

对几种方程求解算法的不同实现进行了比较。于FORTRAN函数对比，汇编语言函数求解方程系统需要一半的中央处理器执行时间。用汇编语言编码这些函数因此与代价值当。求解时间上的进一步减少是通过对每个电路产生特定的没有环路的机器代码指令集合；然而，代码产生要求额外的内存来存储这些代码。对于DC和瞬态分析，方程系统是实数，内存上的增加对得起执行时间上的减少。然而，对AC分析，方程集合是复数，而机器代码的产生几乎加倍了内存要求，但是在求解时间上只减少了15\%。在SPICE中，机器代码只对DC和瞬态分析产生；对于AC分析，一种有效的汇编语言函数被用来求解复数方程系统。

在随机生成的矩阵上进行的测试对线性求解函数在较大的电路规模上如何表现提供了很好的指示。随着方程系统规模的增加，填元占的比例量也会增加，因为填元可以产生额外的填元项。因此，中央内存要求和求解执行时间并不是方程系统规模的简单的线性函数。经验上，操作数正比于$n^{1.24}$，而非零系数的数目，包括填元项，正比于$n^{1.11}$。该数据表明求解用描述过的稀疏矩阵方法的1000个方程系统是可行的。最后，对于典型电路，线性方程求解只消耗10\%-20\%的Newton迭代需要的计算代价；计算工作的其余代价消耗在方程的构建上。
